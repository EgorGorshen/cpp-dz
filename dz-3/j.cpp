//* Copyright 2025 EgorGorshen */

// J. Ассоциативная операция С++
//
// Ограничение времени      1 секунда
// Ограничение памяти       64 Мб
// Ввод                     стандартный ввод или input.txt
// Вывод                    стандартный вывод или output.txt
//
// Пусть на множестве AA введена бинарная операция *, то есть, каждой
// упорядоченной паре элементов x,y∈Ax,y∈A сопоставлен элемент x∗y∈Ax∗y∈A.
//
// Такая операция называется ассоциативной, если (x∗y)∗z=x∗(y∗z)(x∗y)∗z=x∗(y∗z)
// для любых элементов x,y,z∈Ax,y,z∈A.
//
// Примеры ассоциативных операций - сложение или умножение обычных чисел (в
// школе это называли сочетательным законом), или композиция функций. Примеры
// неассоцитивных операций - вычитание, деление, возведение в степень.
// Математики называют множество с ассоциативной операцией полугруппой.
//
// Вам нужно проверить, является ли заданная операция на nn-элементном множестве
// AA ассоциативной. Будем считать, что элементы множества AA пронумерованы
// числами от 0 до n−1n−1:
// A={a0,…,an−1}.A={a0​,…,an−1​}. Формат ввода
//
// В первой строке указано натуральное число nn, не превосходящее 100.
//
// Далее следует n2n2 чисел (каждое в пределах от 0 до n−1n−1), которые
// построчно задают матрицу операции *. Это значит, что на пересечении ii-й
// строки и jj-го столбца этой матрицы стоит номер элемента
// ai∗ajai​∗aj​ (нумерация ведётся с нуля).
// Формат вывода
//
// Выведите YES, если операция ассоциативна, и NO в противном случае.
#include <iostream>

int main(int argc, char *argv[]) {
  int n;
  std::cin >> n;
  int **operation = new int *[n];
  for (int i = 0; i < n; ++i) {
    operation[i] = new int[n];

    for (int j = 0; j < n; ++j) {
      std::cin >> operation[i][j];
    }
  }

  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
      for (int k = 0; k < n; ++k) {
        if (operation[operation[i][j]][k] != operation[i][operation[j][k]]) {
          std::cout << "NO" << std::endl;
          return 0;
        }
      }
    }
  }

  std::cout << "YES" << std::endl;

  for (int i = 0; i < n; ++i) {
    delete[] operation[i];
  }
  delete[] operation;

  return 0;
}
